#include <pthread.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

#include "questions.h"
#include "random.h"

// Number of threads used by create_qset
#define THREAD_NUM 4

volatile static question *last_question = NULL;
pthread_mutex_t qset_mutex;

// Fills out answer and prompt part of question, returns true or false based on execution
static bool set_question(question *question, int *topics)
{
    // Choosing whether the question has a single topic or multiple
    bool single_topic = (bool) msws_uint(0, 1);

    switch (single_topic)
    {
        // Question generation for single topic questions
        case true:
            break;
        
        // Question generation for multi-topic questions
        case false:
            break;
    }

    return true;
}

// Generates question into qset in question.h. Can be multi-threaded.
static int qns_factory(create_arg args)
{
    int q_num = args.q_num;
    int q_count = 0;

    // Generates questions
    for (;q_count < q_num; q_count++)
    {
        // Generates question
        question *current_question = malloc(sizeof(question));
        current_question->next = NULL;
        current_question->answer = NULL;
        current_question->prompt = NULL;

        if (current_question == NULL)
        {
            return -1;
        }

        // Generate prompt and answers
        if (!set_question(current_question, args.topic))
        {
            return -2;
        }

        // Add to question set
        pthread_mutex_lock(&qset_mutex);

        question *curr_last_question = (question *)last_question;
        if (curr_last_question == NULL)
        {
            curr_last_question = current_question;
            qset = current_question;
        }
        else
        {
            curr_last_question->next = current_question;
        }
        last_question = current_question;

        pthread_mutex_unlock(&qset_mutex);
    }

    return q_count;
}

// A function that manages qns_factory
int create_qset(create_arg args)
{
    int q_num = args.q_num;
    int total_q = 0;

    // Initialise mutex
    pthread_mutex_init(&qset_mutex, NULL);

    // Number of questions generated by thread.
    int num_p_thread[THREAD_NUM];
    
    for (int i = 0; i < THREAD_NUM; i++)
    {
        num_p_thread[i] = q_num / THREAD_NUM;
    }
    
    // In case q_num is indivisable by THREADNUM add one question to each thread until no remainder
    int remainder = q_num % THREAD_NUM;
    
    if (remainder != 0)
    {
        for (int i = 0; i < remainder; i++)
        {
            num_p_thread[i]++;
        }
    }

    // Place to store thread ids
    pthread_t thread_ids[THREAD_NUM];
    
    // Creating threads
    for (int i = 0; i < THREAD_NUM; i++)
    {
        create_arg thread_args = {args.topic, num_p_thread[i]};

        // Error detection
        if (pthread_create(&thread_ids[i], NULL, &qns_factory, &thread_args))
        {
            return -1;
        }
    }

    // To store return value
    int retval;

    // Terminating threads
    while (total_q != q_num)
    {
        for (int i = 0; i < THREAD_NUM; i++)
        {
            // Check if it is a valid thread
            if (thread_ids[i] != -1)
            {
                // Error detection
                if (pthread_join(thread_ids[i], &retval))
                {
                    return -2;
                }

                // Reset thread ID
                thread_ids[i] = -1;

                // Update the total amount of questions generated
                total_q += retval;

                // Check if code did not execute
                if (retval < num_p_thread[i])
                {
                    num_p_thread[i] -= retval;

                    // Execute more threads
                    create_arg thread_args = {args.topic, num_p_thread[i]};

                    if (pthread_create(&thread_ids[i], NULL, &qns_factory, &thread_args))
                    {
                        return -1;
                    }
                }
            }
        }
    }

    // Destroy mutex
    pthread_mutex_destroy(&qset_mutex);

    return total_q;
}

// Frees question set using Iteration
void free_qset()
{
    question *temp = NULL;

    // Loop
    while (qset != NULL)
    {
        // Zeroing and freeing all values
        if (qset->answer != NULL)
        {
            free(qset->answer);
            qset->answer = NULL;
        }

        if (qset->prompt != NULL)
        {
            free(qset->prompt);
            qset->prompt = NULL;
        }

        // Freeing actual node
        temp = qset;
        qset = temp->next;

        free(temp);
        temp = NULL;
    }

    return;
}
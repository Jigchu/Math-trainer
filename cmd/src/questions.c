#include <pthread.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

#include "questions.h"
#include "random.h"

// Number of threads used by create_qset
#define THREAD_NUM 4

volatile static question *last_question = NULL;
pthread_mutex_t qset_mutex;

// A function that handles qns_factory and facilitates the creation of a question set
int create_qset(int *topics, int *num_ptr)
{
    int q_num = *num_ptr;

    // Number of questions generated by thread.
    int num_p_thread[THREAD_NUM];
    
    for (int i = 0; i < THREAD_NUM; i++)
    {
        num_p_thread[i] = q_num / THREAD_NUM;
    }
    
    // In case q_num is indivisable by THREADNUM add one question to each thread until no remainder
    int remainder = q_num % THREAD_NUM;
    
    if (remainder != 0)
    {
        for (int i = 0; i < remainder; i++)
        {
            num_p_thread[i]++;
        }
    }

    // Place to store thread ids
    pthread_t thread_ids[THREAD_NUM];
    
}

// Generates question into qset in question.h. Can be multi-threaded.
static int qns_factory(int *topics, int *num_ptr)
{
    int q_num = *num_ptr;
    int q_count = 0;

    // Generates questions
    for (;q_count < q_num; q_count++)
    {
        // Generates question
        question *current_question = malloc(sizeof(question));
        current_question->next = NULL;

        if (current_question == NULL)
        {
            return -1;
        }

        // Generate prompt and answers
        /*
        *
        *
        */

        // Add to question set
        pthread_mutex_lock(&qset_mutex);

        question *curr_last_question = last_question;
        if (curr_last_question = NULL)
        {
            curr_last_question = current_question;
            qset = current_question;
        }
        else
        {
            curr_last_question->next = current_question;
        }
        last_question = current_question;

        pthread_mutex_unlock(&qset_mutex);
    }

    return q_count;
}

// Frees question set using Iteration
void free_qset(question *qset)
{
    question *temp = NULL;

    // Loop
    while (qset != NULL)
    {
        // Zeroing and freeing all values
        if (qset->answer != NULL)
        {
            free(qset->answer);
            qset->answer = NULL;
        }

        if (qset->prompt != NULL)
        {
            free(qset->prompt);
            qset->prompt = NULL;
        }

        // Freeing actual node
        temp = qset;
        qset = temp->next;

        free(temp);
        temp = NULL;
    }

    return;
}

// Fills out answer and prompt part of question, returns true or false based on execution
static bool set_question(question *question)
{
    // Choosing whether the question has a single topic or multiple
    bool single_topic = (bool) msws_uint(0, 1);

    switch (single_topic)
    {
        // Question generation for single topic questions
        case true:
            break;
        
        // Question generation for multi-topic questions
        case false:
            break;
    }

    return true;
}